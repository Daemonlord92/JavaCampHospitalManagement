# OOP Concepts Applied in Hospital Management System

## Introduction

This document explains how Object-Oriented Programming (OOP) principles are applied throughout the Hospital Management System. Understanding these concepts is crucial for writing maintainable, scalable enterprise applications.

## The Four Pillars of OOP

### 1. Encapsulation

**Definition**: Bundling data and methods that operate on that data within a single unit (class), and controlling access through visibility modifiers.

#### Examples in Our Project

**Entity Encapsulation - Patient Class**:
```java
@Entity
@Data  // Generates getters/setters with proper encapsulation
public class Patient extends AuditableEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;  // Private fields - data hiding
    
    @Column(nullable = false, length = 150)
    @NotNull(message = "First name is required")
    private String fname;
    
    @Column(nullable = false, length = 150)
    private String lname;
    
    private List<String> allergies;
    
    @ManyToOne
    private Doctor primaryDoctor;
}
```

**Why This Matters**:
- Fields are `private` - cannot be accessed directly from outside
- Access is controlled through getters/setters (generated by Lombok's `@Data`)
- Validation rules are attached to fields
- Internal representation can change without affecting external code

**Service Layer Encapsulation**:
```java
@Service
@RequiredArgsConstructor
public class PatientServiceImpl implements PatientService {
    // Dependencies are private and final - immutable after construction
    private final PatientRepository patientRepository;
    private final DoctorRepository doctorRepository;
    
    // Public interface methods expose only what's needed
    @Override
    public PatientInformation createPatient(PostNewPatientRequest request) {
        // Internal implementation details are hidden
        Patient newPatient = PatientMapper.toEntity(request);
        newPatient = patientRepository.save(newPatient);
        return PatientMapper.toDto(newPatient);
    }
}
```

**Benefits**:
- **Data Hiding**: Internal state cannot be corrupted by external code
- **Controlled Access**: Changes go through validation
- **Maintainability**: Internal changes don't break external code
- **Security**: Sensitive data can be protected

### 2. Inheritance

**Definition**: Creating new classes based on existing ones, inheriting their properties and behaviors.

#### Examples in Our Project

**Entity Inheritance - AuditableEntity**:
```java
@MappedSuperclass  // JPA: Fields will be included in child entity tables
public abstract class AuditableEntity {
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// Child classes inherit auditing fields
@Entity
public class Patient extends AuditableEntity {
    // Patient-specific fields
    private String fname;
    private String lname;
    // ... inherited: createdAt, updatedAt
}

@Entity
public class Doctor extends AuditableEntity {
    // Doctor-specific fields
    private String firstName;
    private String lastName;
    // ... inherited: createdAt, updatedAt
}
```

**Why This Design?**:
- **DRY Principle**: Don't Repeat Yourself - auditing logic in one place
- **Consistency**: All entities have creation/update timestamps
- **Maintainability**: Add new audit fields once, available everywhere
- **JPA Integration**: `@MappedSuperclass` tells Hibernate to include fields in child tables

**Interface Inheritance - UserDetails**:
```java
@Entity
public class UserCredential extends AuditableEntity implements UserDetails {
    @Id
    private String email;
    private String password;
    private HospitalRole role;
    
    // Implementing UserDetails contract required by Spring Security
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role.toString()));
    }
    
    @Override
    public String getUsername() {
        return email;
    }
    
    // ... other UserDetails methods
}
```

**Benefits of Interface Inheritance**:
- **Polymorphism**: `UserCredential` can be used wherever `UserDetails` is expected
- **Framework Integration**: Spring Security works with our custom entity
- **Contract Compliance**: Must implement all interface methods

**Type Hierarchy**:
```
Object (root of all Java classes)
  ↑
AuditableEntity (abstract base for entities)
  ↑
  ├── Patient
  ├── Doctor
  └── UserCredential (also implements UserDetails)
```

### 3. Polymorphism

**Definition**: Objects of different classes can be treated through a common interface. "Many forms" - same method call, different behavior.

#### Method Overriding

**Example - Service Implementations**:
```java
// Interface defines the contract
public interface PatientService {
    PatientInformation getPatientById(long id);
}

// Implementation 1 (Primary)
@Service
@Primary
public class PatientServiceImpl implements PatientService {
    @Override
    public PatientInformation getPatientById(long id) {
        return patientRepository.findById(id)
            .map(PatientMapper::toDto)
            .orElseThrow(() -> new PatientNotFoundException("Patient not found"));
    }
}

// Could have alternative implementation (e.g., caching version)
@Service
public class CachedPatientServiceImpl implements PatientService {
    @Override
    public PatientInformation getPatientById(long id) {
        // Check cache first, then database
    }
}
```

**Polymorphic Usage**:
```java
@RestController
@RequiredArgsConstructor
public class PatientController {
    // Depends on interface, not implementation
    private final PatientService patientService;  // Could be any implementation!
    
    @GetMapping("/{id}")
    public ResponseEntity<PatientInformation> getPatientById(@PathVariable long id) {
        // Calls the actual implementation's method at runtime
        return ResponseEntity.ok(patientService.getPatientById(id));
    }
}
```

#### Runtime Polymorphism with Spring Security

```java
@Configuration
public class ApplicationConfig {
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> {
            // Returns UserCredential but treated as UserDetails
            UserCredential user = userCredentialRepository.findById(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
            return user;  // Polymorphism: UserCredential IS-A UserDetails
        };
    }
}
```

#### Functional Interface Polymorphism

**Java 8 Functional Interfaces**:
```java
// In JwtService.java
private <T> T extractClaim(String token, Function<Claims, T> claimResolver) {
    final Claims claims = extractAllClaims(token);
    return claimResolver.apply(claims);  // Polymorphic behavior
}

// Different behaviors passed as lambdas
public String extractEmail(String token) {
    return extractClaim(token, Claims::getSubject);  // One behavior
}

public Date extractExpiration(String token) {
    return extractClaim(token, Claims::getExpiration);  // Different behavior
}
```

**Benefits**:
- **Flexibility**: Swap implementations without changing client code
- **Testability**: Easy to mock interfaces
- **Extensibility**: Add new implementations without modifying existing code
- **Loose Coupling**: Clients depend on abstractions, not concrete classes

### 4. Abstraction

**Definition**: Hiding complex implementation details and exposing only essential features through simplified interfaces.

#### Interface Abstraction

**Repository Abstraction**:
```java
// Spring Data JPA provides complete abstraction over data access
public interface PatientRepository extends JpaRepository<Patient, Long> {
    // No implementation needed! Spring generates it
    List<Patient> findAllByDobOrderByLnameAsc(LocalDate dob);
    
    @Query("SELECT p FROM Patient p WHERE p.lname LIKE %?1% OR p.fname LIKE %?1%")
    List<Patient> searchByName(String name);
}

// Usage - completely abstracted from SQL
List<Patient> patients = patientRepository.findAllByDobOrderByLnameAsc(someDate);
// Behind the scenes: SELECT * FROM eva_patients WHERE dob = ? ORDER BY lname ASC
```

**Service Layer Abstraction**:
```java
public interface PatientService {
    // Abstract contract - no implementation details visible
    PatientInformation createPatient(PostNewPatientRequest request);
    List<PatientInformation> getAllPatients();
    PatientInformation getPatientById(long id);
    void deletePatientById(long id);
    PatientInformation updatePatient(long id, UpdatePatientRequest request);
}

// Controllers work with abstraction, don't know implementation details
@RestController
@RequiredArgsConstructor
public class PatientController {
    private final PatientService patientService;  // Abstract interface
    
    @GetMapping("/")
    public ResponseEntity<List<PatientInformation>> getPatientsIndex() {
        // Don't know (or care) how it's implemented
        return ResponseEntity.ok(patientService.getAllPatients());
    }
}
```

#### Abstract Classes

```java
@MappedSuperclass
public abstract class AuditableEntity {
    // Cannot instantiate directly - provides template for child classes
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Could have abstract methods that children must implement
    // public abstract String getEntityType();
}
```

**Abstraction Levels in Our Application**:

```
High Level (Simple)
    ↓
Controller → uses → Service Interface
    ↓
Service Implementation → uses → Repository Interface
    ↓
Spring Data JPA → uses → EntityManager
    ↓
Hibernate → generates → SQL
    ↓
JDBC → communicates with → Database
    ↓
Low Level (Complex)
```

**Benefits**:
- **Simplicity**: Work at a higher level without worrying about details
- **Maintainability**: Change implementation without affecting abstractions
- **Reduced Complexity**: Focus on WHAT, not HOW
- **Reusability**: Abstract concepts applicable in multiple contexts

## Additional OOP Concepts

### Composition Over Inheritance

**Definition**: Build complex objects by combining simpler ones rather than inheriting.

**Example - Entity Relationships**:
```java
@Entity
public class Patient extends AuditableEntity {
    // Composition: Patient HAS-A Doctor (not IS-A Doctor)
    @ManyToOne
    private Doctor primaryDoctor;
    
    // Composition: Patient HAS-A list of Appointments
    @OneToMany(mappedBy = "patient")
    private List<Appointment> appointments;
    
    // Composition: Patient HAS-A list of allergies
    private List<String> allergies;
}
```

**Why Composition Here?**:
- More flexible than inheritance
- Represents real-world relationships
- Can change relationships at runtime
- Avoids deep inheritance hierarchies

### Dependency Injection (IoC Container)

**Constructor Injection with Lombok**:
```java
@Service
@RequiredArgsConstructor  // Generates constructor for final fields
public class PatientServiceImpl implements PatientService {
    // Dependencies are injected, not created
    private final PatientRepository patientRepository;
    private final DoctorRepository doctorRepository;
    
    // Spring automatically creates and injects dependencies
}
```

**Benefits**:
- **Loose Coupling**: Don't instantiate dependencies
- **Testability**: Easy to inject mocks
- **Single Responsibility**: Focus on business logic, not object creation
- **Flexibility**: Spring manages object lifecycle

### Immutability

**Using Java Records for DTOs**:
```java
// Records are immutable by default (final fields, no setters)
public record PatientInformation(
    long id,
    String firstName,
    String lastName,
    String phoneNumber,
    String address,
    String dateOfBirth,
    String biologicalSex,
    String allergies
) {
    // All fields are final
    // No setters - object cannot be modified after creation
}
```

**Benefits**:
- **Thread Safety**: Immutable objects are inherently thread-safe
- **Predictability**: State doesn't change unexpectedly
- **Caching**: Safe to cache and reuse
- **Functional Programming**: Works well with streams and lambdas

### Type Safety with Enums

```java
public enum BiologicalSex {
    MALE, FEMALE, OTHER
}

public enum Status {
    SCHEDULED, COMPLETED, CANCELLED
}

@Entity
public class Patient {
    @Column(nullable = false)
    private BiologicalSex biologicalSex;  // Type-safe, can't be invalid value
}
```

**Benefits**:
- **Type Safety**: Compile-time checking
- **Readability**: Self-documenting code
- **IDE Support**: Autocomplete and refactoring
- **No Magic Strings**: Prevents typos

## OOP Design Principles (SOLID)

### Single Responsibility Principle (SRP)

Each class has one reason to change.

```java
// PatientController - ONLY handles HTTP concerns
@RestController
public class PatientController {
    // Delegates business logic to service
}

// PatientService - ONLY handles business logic
@Service
public class PatientServiceImpl implements PatientService {
    // Delegates data access to repository
}

// PatientRepository - ONLY handles data access
public interface PatientRepository extends JpaRepository<Patient, Long> {
}

// PatientMapper - ONLY handles Entity ↔ DTO conversion
public class PatientMapper {
    public static Patient toEntity(PostNewPatientRequest request) { }
    public static PatientInformation toDto(Patient patient) { }
}
```

### Open/Closed Principle (OCP)

Open for extension, closed for modification.

```java
// Can add new implementations without modifying existing code
public interface PatientService {
    PatientInformation getPatientById(long id);
}

// Original implementation
@Service
public class PatientServiceImpl implements PatientService { }

// New implementation - extends behavior without modifying original
@Service
public class AuditedPatientServiceImpl implements PatientService {
    // Logs all patient access
}
```

### Liskov Substitution Principle (LSP)

Subtypes must be substitutable for their base types.

```java
// Any PatientService implementation can be used
@RestController
public class PatientController {
    private final PatientService service;  // Could be ANY implementation
    
    public ResponseEntity<PatientInformation> get(long id) {
        return ResponseEntity.ok(service.getPatientById(id));  // Works with any impl
    }
}
```

### Interface Segregation Principle (ISP)

Many specific interfaces better than one general-purpose interface.

```java
// Good: Focused interfaces
public interface PatientService {
    PatientInformation createPatient(PostNewPatientRequest request);
    PatientInformation getPatientById(long id);
}

public interface DoctorService {
    DoctorInformation createDoctor(PostNewDoctorRequest request);
    DoctorInformation getDoctorById(long id);
}

// Bad: One large interface forcing unnecessary implementations
// public interface HospitalService {
//     PatientInformation createPatient(...);
//     DoctorInformation createDoctor(...);
//     AppointmentInformation createAppointment(...);
//     // Classes implementing this must implement ALL methods
// }
```

### Dependency Inversion Principle (DIP)

Depend on abstractions, not concretions.

```java
// Good: Depends on interface
@Service
public class PatientServiceImpl implements PatientService {
    private final PatientRepository repository;  // Interface dependency
}

// Bad: Depends on concrete class
// private final PatientRepositoryImpl repository;  // Tight coupling!
```

## Real-World Benefits

### Maintainability
- Clear separation of concerns
- Easy to locate and fix bugs
- Changes isolated to specific classes

### Testability
- Mock interfaces easily
- Test each layer independently
- No need for database in unit tests

### Scalability
- Add new features without breaking existing code
- Multiple implementations can coexist
- Easy to refactor and optimize

### Team Collaboration
- Clear contracts between components
- Multiple developers can work on different layers
- Less merge conflicts

## Interview Questions You Can Answer Now

1. **Q: Explain encapsulation in your project.**
   - A: All entity fields are private with controlled access through getters/setters. Services encapsulate business logic, exposing only necessary methods through interfaces.

2. **Q: Give an example of inheritance.**
   - A: `AuditableEntity` is a base class that `Patient`, `Doctor`, and `UserCredential` extend to inherit audit timestamps.

3. **Q: How does your application use polymorphism?**
   - A: Controllers depend on service interfaces. At runtime, Spring injects the actual implementation, allowing different behaviors without changing controller code.

4. **Q: What abstraction exists in your data layer?**
   - A: Spring Data JPA abstracts database operations. We define interfaces, and Spring generates implementations automatically.

5. **Q: How do you follow SOLID principles?**
   - A: Services have single responsibilities, interfaces allow extensibility, implementations are substitutable, interfaces are focused, and we depend on abstractions.

## Next Steps

Continue to:
- [IoC and Dependency Injection](./03-IOC-AND-DI.md)
- [Design Patterns](./04-DESIGN-PATTERNS.md)

